// import { supabase } from '../lib/supabase';
import { localProjectService } from './LocalProjectService';
import { projectService } from './ProjectService';

export interface FSNode {
    id: string;
    project_id: string;
    parent_id: string | null;
    user_id: string;
    name: string;
    type: 'file' | 'folder';
    language?: 'typescript' | 'python' | 'java';
    content?: string;
    created_at: string;
}

export class FileSystemService {

    // Get all nodes for a project
    async getNodes(projectId: string, userId: string): Promise<FSNode[]> {
        try {
            // Read from REMOTE (Primary)
            const remoteFiles = await projectService.getFSNodes(projectId, userId);

            // Transform snake_case to match interface if needed, or ensuring types line up.
            // Firestore stores: { id, project_id, parent_id, user_id, name, type, ... }
            // Let's ensure uniform return.
            // If remote is empty, check local?
            if (remoteFiles.length === 0) {
                console.log('[FileSystem] Remote empty, checking local backup...');
                const localFiles = await localProjectService.getFSNodes(projectId);
                if (localFiles.length > 0) {
                    // Sync Up opportunity? 
                    // For now just return local
                    return localFiles;
                }
            }

            const files = remoteFiles.map(f => ({
                ...f,
                parent_id: f.parent_id || f.parentId // Handle casing diffs if any
            }));

            // HEAL: Sync Remote -> Local
            // This ensures subsequent updateContent calls (which look up locally) succeed.
            // We run this without awaiting to not block UI read? 
            // Better to await to ensure consistency immediately.
            try {
                await localProjectService.saveFSNodes(projectId, files);
            } catch (e) {
                console.error('[FileSystem] Healing disabled/failed:', e);
            }


            // Sorting: folders first, then names.
            files.sort((a: any, b: any) => {
                if (a.type === b.type) return a.name.localeCompare(b.name);
                return a.type === 'folder' ? -1 : 1;
            });
            return files;
        } catch (error: any) {
            console.error('[FileSystem] Remote read failed, falling back to local:', error);
            // Fallback to local
            const localFiles = await localProjectService.getFSNodes(projectId);
            return localFiles;
        }
    }

    async createNode(params: {
        projectId: string;
        userId: string;
        parentId: string | null;
        name: string;
        type: 'file' | 'folder';
        language?: string;
        content?: string;
    }): Promise<FSNode> {
        const newNode = {
            project_id: params.projectId,
            user_id: params.userId,
            parent_id: params.parentId,
            name: params.name,
            type: params.type,
            language: params.language,
            content: params.content || '',
            created_at: new Date().toISOString()
        };

        // 1. Create Remote
        const savedRemote = await projectService.createFSNode(params.projectId, newNode, params.userId);

        // 2. Backup Local
        try {
            // Use the ID generated by Remote (if any) or existing
            await localProjectService.saveFSNode(params.projectId, { ...newNode, id: savedRemote.id });
        } catch (e) {
            console.error('[FileSystem] Local backup failed:', e);
        }

        return savedRemote;
    }

    async updateContent(id: string, content: string, userId: string): Promise<void> {
        console.log(`[FileSystem] Updating content for node ${id}`);

        // We need ProjectId to talk to Firestore correctly (collection path).
        // BUT API currently only sends ID in param.
        // We have to scan or look it up.
        // Option 1: Find project first via Remote Global Query?
        // ProjectService doesn't have global query for FS yet.
        // Option 2: Rely on Local Lookup to find Project ID, then update both?

        // Let's use Local Service to find the node & projectId
        const projects = await localProjectService.getAllProjects(userId); // Local is fast
        let targetProject: any = null;
        let targetNode: any = null;

        for (const p of projects) {
            const files = await localProjectService.getFSNodes(p.id);
            const file = files.find((f: any) => f.id === id);
            if (file) {
                targetProject = p;
                targetNode = file;
                break;
            }
        }

        if (!targetProject) {
            // If not in local, we can't easily find it in Firestore without a global index.
            // Assuming Local is always in sync for lookup.
            console.error(`[FileSystem] Node ${id} not found in local index. Cannot determine Project ID.`);
            throw new Error('File not found');
        }

        // 1. Update Remote
        try {
            await projectService.updateFSNode(targetProject.id, id, { content, updated_at: new Date().toISOString() }, userId);
        } catch (error: any) {
            console.warn(`[FileSystem] Remote update failed for ${id}, attempting Lazy Sync (Create)...`);
            // If remote doc is missing (common for pre-existing files), create it now.
            const fullNode = {
                ...targetNode,
                content,
                updated_at: new Date().toISOString()
            };
            await projectService.createFSNode(targetProject.id, fullNode, userId);
        }

        // 2. Update Local
        try {
            targetNode.content = content;
            targetNode.updated_at = new Date().toISOString();
            await localProjectService.saveFSNode(targetProject.id, targetNode);
        } catch (e) {
            console.error('[FileSystem] Local update failed:', e);
        }
    }

    async renameNode(id: string, name: string, userId: string): Promise<void> {
        console.log(`[FileSystem] Renaming node ${id} to ${name}`);

        // Find Project ID via Local
        const projects = await localProjectService.getAllProjects(userId);
        let targetProject: any = null;
        let targetNode: any = null;

        for (const p of projects) {
            const files = await localProjectService.getFSNodes(p.id);
            const file = files.find((f: any) => f.id === id);
            if (file) {
                targetProject = p;
                targetNode = file;
                break;
            }
        }

        if (!targetProject) throw new Error('File not found');

        // 1. Remote
        try {
            await projectService.updateFSNode(targetProject.id, id, { name, updated_at: new Date().toISOString() }, userId);
        } catch (error: any) {
            console.warn(`[FileSystem] Remote rename failed for ${id}, attempting Lazy Sync...`);
            const fullNode = {
                ...targetNode,
                name,
                updated_at: new Date().toISOString()
            };
            await projectService.createFSNode(targetProject.id, fullNode, userId);
        }

        // 2. Local
        try {
            targetNode.name = name;
            targetNode.updated_at = new Date().toISOString();
            await localProjectService.saveFSNode(targetProject.id, targetNode);
        } catch (e) {
            console.error('[FileSystem] Local rename failed:', e);
        }
    }

    async deleteNode(id: string, userId: string): Promise<void> {
        console.log(`[FileSystem] Deleting node ${id}`);
        // Find Project ID via Local
        const projects = await localProjectService.getAllProjects(userId);
        let targetProject: any = null;

        for (const p of projects) {
            const files = await localProjectService.getFSNodes(p.id);
            const file = files.find((f: any) => f.id === id);
            if (file) {
                targetProject = p;
                break;
            }
        }

        if (!targetProject) {
            // Optimistic delete? Or just return.
            return;
        }

        // 1. Remote
        await projectService.deleteFSNode(targetProject.id, id, userId);

        // 2. Local
        try {
            await localProjectService.deleteFSNode(targetProject.id, id);
        } catch (e) {
            console.error('[FileSystem] Local delete failed:', e);
        }
    }

    // Check if file exists in folder
    async checkExists(projectId: string, parentId: string | null, name: string): Promise<boolean> {
        const files = await localProjectService.getFSNodes(projectId);
        return files.some((f: any) => f.name === name && f.parent_id === parentId);
    }
}

export const fileSystemService = new FileSystemService();
