// import { supabase } from '../lib/supabase';
import { localProjectService } from './LocalProjectService';
import { projectService } from './ProjectService';
import { logger } from '../../lib/logger';

export interface FSNode {
    id: string;
    project_id: string;
    parent_id: string | null;
    user_id: string;
    name: string;
    type: 'file' | 'folder';
    language?: 'typescript' | 'python' | 'java';
    content?: string;
    created_at: string;
    updated_at?: string;
}

export class FileSystemService {

    // Get all nodes for a project
    async getNodes(projectId: string, userId: string): Promise<FSNode[]> {
        try {
            // Read from REMOTE (Primary)
            const remoteFiles = await projectService.getFSNodes(projectId, userId);

            // Transform snake_case to match interface if needed, or ensuring types line up.
            // Firestore stores: { id, project_id, parent_id, user_id, name, type, ... }
            // Let's ensure uniform return.
            // If remote is empty, check local?
            if (remoteFiles.length === 0) {
                logger.debug('Remote empty, checking local backup', { projectId });
                const localFiles = await localProjectService.getFSNodes(projectId);
                if (localFiles.length > 0) {
                    // Sync Up opportunity? 
                    // For now just return local
                    return localFiles;
                }
            }

            const files = remoteFiles.map(f => ({
                ...f,
                parent_id: f.parent_id || f.parentId // Handle casing diffs if any
            }));

            // HEAL: Sync Remote -> Local
            // This ensures subsequent updateContent calls (which look up locally) succeed.
            // We run this without awaiting to not block UI read? 
            // Better to await to ensure consistency immediately.
            try {
                await localProjectService.saveFSNodes(projectId, files);
            } catch (error: unknown) {
                if (error instanceof Error) {
                    logger.warn('Failed to sync remote to local', error, { projectId });
                }
            }


            // Sorting: folders first, then names.
            files.sort((a: FSNode, b: FSNode) => {
                if (a.type === b.type) return a.name.localeCompare(b.name);
                return a.type === 'folder' ? -1 : 1;
            });
            return files;
        } catch (error: unknown) {
            if (error instanceof Error) {
                logger.warn('Remote read failed, falling back to local', error, { projectId });
            }
            // Fallback to local
            const localFiles = await localProjectService.getFSNodes(projectId);
            return localFiles;
        }
    }

    // Get Single Node by ID (Scan all projects locally for speed/simplicity)
    async getNode(id: string, userId: string): Promise<FSNode | null> {
        // Since we don't have projectId, we scan local projects
        const projects = await localProjectService.getAllProjects(userId);

        for (const p of projects) {
            const files = await localProjectService.getFSNodes(p.id);
            const file = files.find((f: FSNode) => f.id === id);
            if (file) {
                // Ensure we return clean FSNode
                return file as FSNode;
            }
        }

        // Fallback: Query remote if we had a global index, but we don't.
        // Assuming local sync is good enough for now.
        return null;
    }

    async createNode(params: {
        projectId: string;
        userId: string;
        parentId: string | null;
        name: string;
        type: 'file' | 'folder';
        language?: string;
        content?: string;
    }): Promise<FSNode> {
        const newNode = {
            project_id: params.projectId,
            user_id: params.userId,
            parent_id: params.parentId,
            name: params.name,
            type: params.type,
            language: params.language,
            content: params.content || '',
            created_at: new Date().toISOString()
        };

        // 1. Create Remote
        const savedRemote = await projectService.createFSNode(params.projectId, newNode, params.userId);

        // 2. Backup Local
        try {
            // Use the ID generated by Remote (if any) or existing
            await localProjectService.saveFSNode(params.projectId, { ...newNode, id: savedRemote.id });
        } catch (error: unknown) {
            if (error instanceof Error) {
                logger.error('Local backup failed after node creation', error, { projectId: params.projectId, nodeId: savedRemote.id });
            }
        }

        return savedRemote;
    }

    async updateContent(id: string, content: string, userId: string): Promise<void> {
        logger.debug('Updating content for node', { nodeId: id, contentLength: content.length });

        // We need ProjectId to talk to Firestore correctly (collection path).
        // BUT API currently only sends ID in param.
        // We have to scan or look it up.
        // Option 1: Find project first via Remote Global Query?
        // ProjectService doesn't have global query for FS yet.
        // Option 2: Rely on Local Lookup to find Project ID, then update both?

        // Let's use Local Service to find the node & projectId
        const projects = await localProjectService.getAllProjects(userId); // Local is fast
        let targetProject = null;
        let targetNode: FSNode | null = null;

        for (const p of projects) {
            const files = await localProjectService.getFSNodes(p.id);
            const file = files.find((f: FSNode) => f.id === id);
            if (file) {
                targetProject = p;
                targetNode = file;
                break;
            }
        }

        if (!targetProject || !targetNode) {
            // If not in local, we can't easily find it in Firestore without a global index.
            // Assuming Local is always in sync for lookup.
            logger.error('Node not found in local index', undefined, { nodeId: id });
            throw new Error('File not found');
        }

        // 1. Update Remote
        try {
            await projectService.updateFSNode(targetProject.id, id, { content, updated_at: new Date().toISOString() }, userId);
        } catch (error: unknown) {
            if (error instanceof Error) {
                logger.warn('Remote update failed, attempting lazy sync', error, { nodeId: id, projectId: targetProject.id });
            }
            // If remote doc is missing (common for pre-existing files), create it now.
            if (targetNode) {
                const fullNode = {
                    ...targetNode,
                    content,
                    updated_at: new Date().toISOString()
                };
                await projectService.createFSNode(targetProject.id, fullNode, userId);
            }
        }

        // 2. Update Local
        if (targetNode) {
            try {
                targetNode.content = content;
                targetNode.updated_at = new Date().toISOString();
                await localProjectService.saveFSNode(targetProject.id, targetNode);
            } catch (error: unknown) {
                if (error instanceof Error) {
                    logger.error('Local update failed', error, { nodeId: id, projectId: targetProject.id });
                }
            }
        }
    }

    async renameNode(id: string, name: string, userId: string): Promise<void> {
        logger.debug('Renaming node', { nodeId: id, newName: name });

        // Find Project ID via Local
        const projects = await localProjectService.getAllProjects(userId);
        let targetProject = null;
        let targetNode: FSNode | null = null;

        for (const p of projects) {
            const files = await localProjectService.getFSNodes(p.id);
            const file = files.find((f: FSNode) => f.id === id);
            if (file) {
                targetProject = p;
                targetNode = file;
                break;
            }
        }

        if (!targetProject) throw new Error('File not found');

        // 1. Remote
        try {
            await projectService.updateFSNode(targetProject.id, id, { name, updated_at: new Date().toISOString() }, userId);
        } catch (error: unknown) {
            if (error instanceof Error) {
                logger.warn('Remote rename failed, attempting lazy sync', error, { nodeId: id, newName: name });
            }
            const fullNode = {
                ...targetNode,
                name,
                updated_at: new Date().toISOString()
            };
            await projectService.createFSNode(targetProject.id, fullNode, userId);
        }

        // 2. Local
        if (targetNode) {
            try {
                targetNode.name = name;
                targetNode.updated_at = new Date().toISOString();
                await localProjectService.saveFSNode(targetProject.id, targetNode);
            } catch (error: unknown) {
                if (error instanceof Error) {
                    logger.error('Local rename failed', error, { nodeId: id, newName: name });
                }
            }
        }
    }

    async deleteNode(id: string, userId: string): Promise<void> {
        logger.debug('Deleting node', { nodeId: id });
        // Find Project ID via Local
        const projects = await localProjectService.getAllProjects(userId);
        let targetProject = null;

        for (const p of projects) {
            const files = await localProjectService.getFSNodes(p.id);
            const file = files.find((f: FSNode) => f.id === id);
            if (file) {
                targetProject = p;
                break;
            }
        }

        if (!targetProject) {
            // Optimistic delete? Or just return.
            return;
        }

        // 1. Remote
        await projectService.deleteFSNode(targetProject.id, id, userId);

        // 2. Local
        try {
            await localProjectService.deleteFSNode(targetProject.id, id);
        } catch (error: unknown) {
            if (error instanceof Error) {
                logger.error('Local delete failed', error, { nodeId: id, projectId: targetProject.id });
            }
        }
    }

    // Check if file exists in folder
    async checkExists(projectId: string, parentId: string | null, name: string): Promise<boolean> {
        const files = await localProjectService.getFSNodes(projectId);
        return files.some((f: FSNode) => f.name === name && f.parent_id === parentId);
    }
}

export const fileSystemService = new FileSystemService();
